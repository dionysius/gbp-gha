name: promote release

on:
  workflow_call:
    inputs:
      in_days:
        description: 'Number of days to wait after first publish of a pattern match'
        type: number
        default: 7
      release_pattern:
        description: 'Glob-style pattern with capture group to match and group releases, use {*} to mark the version prefix for grouping (can include literal text)'
        type: string
        default: '{debian/*.*}.*'

permissions:
  contents: write

jobs:
  promote:
    runs-on: ubuntu-latest

    steps:
      - name: Promote releases
        uses: actions/github-script@v8
        with:
          script: |
            const inDays = ${{ inputs.in_days }};
            const globPattern = '${{ inputs.release_pattern }}';
            const MS_PER_DAY = 1000 * 60 * 60 * 24;

            // Convert glob pattern with capture group to regex
            // Pattern format: prefix{capture}suffix where {*.*} marks what to capture
            function globToRegex(pattern) {
              // Find the capture group marked with {...}
              const captureMatch = pattern.match(/\{([^}]+)\}/);
              if (!captureMatch) {
                throw new Error('Pattern must contain a capture group marked with {...}');
              }

              const captureContent = captureMatch[1];
              const beforeCapture = pattern.substring(0, captureMatch.index);
              const afterCapture = pattern.substring(captureMatch.index + captureMatch[0].length);

              // Convert glob wildcards to regex
              const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              // * matches a segment (any characters except / and .)
              const globToRegexPart = (str) => escapeRegex(str).replace(/\\\*/g, '[^/.]+');

              // Build regex: capture ONLY what's inside {...}
              // So */{*.*}.* captures just "1.2", while {*/*.*}.* captures "debian/1.2"
              const beforeRegex = globToRegexPart(beforeCapture);
              const captureRegex = globToRegexPart(captureContent);
              const afterRegex = afterCapture ? globToRegexPart(afterCapture) : '.*';

              return new RegExp(`^${beforeRegex}(${captureRegex})${afterRegex}$`);
            }

            const releasePattern = globToRegex(globPattern);

            // Check if we're in tag context - only process specific tag
            const refType = process.env.GITHUB_REF_TYPE;
            const refName = process.env.GITHUB_REF_NAME;

            if (refType === 'tag') {
              const match = refName.match(releasePattern);
              if (!match || !match[1]) {
                console.log(`Tag '${refName}' does not match pattern - skipping`);
                return;
              }
              console.log(`Tag mode: processing only ${refName}`);
            } else {
              console.log('Scheduled/manual mode: processing all matching releases');
            }

            // Get all releases
            const allReleases = await github.paginate(github.rest.repos.listReleases, {
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            // Filter to only releases matching the pattern
            const matchingReleases = allReleases.filter(r => r.tag_name.match(releasePattern)?.[1]);

            // Process all matching prereleases, or only the one matching current tag
            const releasesToProcess = matchingReleases.filter(r => 
              r.prerelease && 
              (refType !== 'tag' || r.tag_name === refName)
            );

            // Process wished releases
            for (const release of releasesToProcess) {
              const tag = release.tag_name;

              // Extract version prefix from first capture group
              const versionPrefix = tag.match(releasePattern)[1];

              console.log(`Processing prerelease: ${tag} (version prefix: ${versionPrefix})`);

              // Find the first release for this version prefix by comparing captures
              const releasesForPrefix = matchingReleases
                .filter(r => r.tag_name.match(releasePattern)[1] === versionPrefix)
                .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

              const firstReleaseDate = new Date(releasesForPrefix[0].created_at);
              const currentDate = new Date();

              // Calculate days elapsed based on calendar days, ignoring time of day
              const firstDay = new Date(firstReleaseDate.toDateString());
              const currentDay = new Date(currentDate.toDateString());
              const daysElapsed = Math.floor((currentDay - firstDay) / MS_PER_DAY);

              console.log(`First release for ${versionPrefix}: ${firstReleaseDate.toISOString()}`);
              console.log(`Days elapsed: ${daysElapsed} (waiting period: ${inDays} days)`);

              // Check if waiting period has passed
              if (daysElapsed >= inDays) {
                console.log(`Promoting ${tag} to full release (waited ${daysElapsed} days)`);

                // Use 'legacy' to let GitHub determine if this should be latest
                await github.rest.repos.updateRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id,
                  prerelease: false,
                  make_latest: 'legacy'
                });
              } else {
                const daysRemaining = inDays - daysElapsed;
                console.log(`Not yet promoting ${tag} (need to wait ${daysRemaining} more days)`);
              }
            }
